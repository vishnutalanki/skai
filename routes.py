from fastapi import FastAPI, HTTPException, APIRouter
from typing import List
from uuid import UUID
from models import User, ParsedLesson, AISuggestion, Feedback, LessonEmbedding
from database import supabase
from uuid import UUID, uuid4
from auth import sign_up, sign_in
from datetime import datetime


llm='gpt-4o'
router = APIRouter()

# Sign up and create a new user
# This endpoint will handle user registration
# It will create a new user in the Supabase Auth system and also insert the user into the public.users table
# The user ID from Supabase Auth will be stored in the public.users table
# The user ID in the public.users table will be a UUID generated by the server
# The email and password will be provided by the user
# The email and password will be passed in the request body
@router.post("/signup")
async def signup(email: str, password: str):
    response = sign_up(email, password)
    
    # Handle errors from Supabase Auth
    if "error" in response:
        raise HTTPException(status_code=400, detail=response["error"]["message"])

    # Log the response to inspect its structure
    print(response)
    user_id = response.user.id

    # Insert into public.users table
    user_data = {
        "id": uuid4(),  # Generate a new UUID for your users table
        "created_at": datetime.now(),        
        "supabase_user_id": user_id,  # Store the auth.users.id in your users table
        "email": email  # You can store other metadata if needed
    }

    user_data = User(**user_data)
    # Insert the user data into the users table
    # Check if the user already exists
    existing_user = supabase.table("users").select("*").eq("supabase_user_id", user_id).execute()
    if existing_user.data:
        raise HTTPException(status_code=400, detail="User already exists")
    # Insert the new user into the users table
    insert_response = supabase.table("users").insert({"id": str(user_data.id), "created_at": str(user_data.created_at),
                                                      "supabase_user_id": str(user_data.supabase_user_id),
                                                      "email": user_data.email}).execute()
    # Check if the insert response contains data
    if not insert_response.data:
        raise HTTPException(status_code=500, detail="Failed to create user in users table")
    
    # Return the response
    return {
        "message": "User created successfully",
        "auth_data": response,
        "user_data": insert_response.data
    }

# Login a user
@router.post("/login")
async def login(email: str, password: str):
    response = sign_in(email, password)
    if "error" in response:
        raise HTTPException(status_code=400, detail=response["error"]["message"])
    return {"message": "User logged in successfully", "data": response}

# Get a user by ID
@router.get("/users/{user_id}", response_model=User)
async def get_user(user_id: UUID):
    # Fetch user from the database
    response = supabase.table("users").select("*").eq("id", str(user_id)).execute()
    if response.status_code != 200 or not response.data:
        raise HTTPException(status_code=404, detail="User not found")
    
    return User(**response.data[0])

# Create a new parsed lesson
@router.post("/lessons/", response_model=ParsedLesson)
async def create_parsed_lesson(lesson: ParsedLesson):
    # Insert lesson into the database
    data = {
        "id": str(lesson.id),
        "user_id": str(lesson.user_id),
        "unit_title": lesson.unit_title,
        "content": lesson.content,
        "created_at": lesson.created_at,
    }
    response = supabase.table("parsed_lessons").insert(data).execute()
    if response.status_code != 201:
        raise HTTPException(status_code=500, detail="Lesson creation failed")
    
    return lesson

# Get a parsed lesson by ID
@router.get("/lessons/{lesson_id}", response_model=ParsedLesson)
async def get_parsed_lesson(lesson_id: UUID):
    # Fetch lesson from the database
    response = supabase.table("parsed_lessons").select("*").eq("id", str(lesson_id)).execute()
    if response.status_code != 200 or not response.data:
        raise HTTPException(status_code=404, detail="Lesson not found")
    
    return ParsedLesson(**response.data[0])

# Create a new AI suggestion
@router.post("/suggestions/", response_model=AISuggestion)
async def create_ai_suggestion(suggestion: AISuggestion):
    # Insert suggestion into the database
    data = {
        "id": str(suggestion.id),
        "lesson_id": str(suggestion.lesson_id),
        "type": suggestion.type,
        "suggestion": suggestion.suggestion,
        "metadata": suggestion.metadata,
        "created_at": suggestion.created_at,
    }
    response = supabase.table("ai_suggestions").insert(data).execute()
    if response.status_code != 201:
        raise HTTPException(status_code=500, detail="Suggestion creation failed")
    
    return suggestion

# Get AI suggestions by lesson ID
@router.get("/suggestions/{lesson_id}", response_model=List[AISuggestion])
async def get_ai_suggestions(lesson_id: UUID):
    # Fetch suggestions from the database
    response = supabase.table("ai_suggestions").select("*").eq("lesson_id", str(lesson_id)).execute()
    if response.status_code != 200:
        raise HTTPException(status_code=500, detail="Failed to fetch suggestions")
    
    return [AISuggestion(**suggestion) for suggestion in response.data]

# Create a new feedback
@router.post("/feedback/", response_model=Feedback)
async def create_feedback(feedback: Feedback):
    # Insert feedback into the database
    data = {
        "id": str(feedback.id),
        "suggestion_id": str(feedback.suggestion_id),
        "feedback_type": feedback.feedback_type,
        "comments": feedback.comments,
        "created_at": feedback.created_at,
    }
    response = supabase.table("feedback").insert(data).execute()
    if response.status_code != 201:
        raise HTTPException(status_code=500, detail="Feedback creation failed")
    
    return feedback

# Get feedback by suggestion ID
@router.get("/feedback/{suggestion_id}", response_model=List[Feedback])
async def get_feedback(suggestion_id: UUID):
    # Fetch feedback from the database
    response = supabase.table("feedback").select("*").eq("suggestion_id", str(suggestion_id)).execute()
    if response.status_code != 200:
        raise HTTPException(status_code=500, detail="Failed to fetch feedback")
    
    return [Feedback(**feedback) for feedback in response.data]

# Create a new lesson embedding
@router.post("/embeddings/", response_model=LessonEmbedding)
async def create_lesson_embedding(embedding: LessonEmbedding):
    # Insert embedding into the database
    data = {
        "id": str(embedding.id),
        "lesson_id": str(embedding.lesson_id),
        "content": embedding.content,
        "embedding": embedding.embedding,
    }
    response = supabase.table("lesson_embeddings").insert(data).execute()
    if response.status_code != 201:
        raise HTTPException(status_code=500, detail="Embedding creation failed")
    
    return embedding

# Get lesson embeddings by lesson ID
@router.get("/embeddings/{lesson_id}", response_model=List[LessonEmbedding])
async def get_lesson_embeddings(lesson_id: UUID):
    # Fetch embeddings from the database
    response = supabase.table("lesson_embeddings").select("*").eq("lesson_id", str(lesson_id)).execute()
    if response.status_code != 200:
        raise HTTPException(status_code=500, detail="Failed to fetch embeddings")
    
    return [LessonEmbedding(**embedding) for embedding in response.data]



